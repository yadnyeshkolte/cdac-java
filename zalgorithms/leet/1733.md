### 1733. Minimum Number of People to Teach

On a social network consisting of m users and some friendships between users, two users can communicate with each other if they know a common language.

You are given an integer n, an array languages, and an array friendships where:

There are n languages numbered 1 through n,

languages[i] is the set of languages the i​​​​​​th​​​​ user knows, and

friendships[i] = [u​​​​​​i​​​, v​​​​​​i] denotes a friendship between the users u​​​​​​​​​​​i​​​​​ and vi.

You can choose one language and teach it to some users so that all friends can communicate with each other. Return the minimum number of users you need to teach.

Note that friendships are not transitive, meaning if x is a friend of y and y is a friend of z, this doesn't guarantee that x is a friend of z.

Example 1:

Input: n = 2, languages = [[1],[2],[1,2]], friendships = [[1,2],[1,3],[2,3]]

Output: 1

Explanation: You can either teach user 1 the second language or user 2 the first language.

Example 2:

Input: n = 3, languages = [[2],[1,3],[1,2],[3]], friendships = [[1,4],[1,2],[3,4],[2,3]]

Output: 2

Explanation: Teach the third language to users 1 and 3, yielding two users to teach.
 
Constraints:

2 <= n <= 500

languages.length == m

1 <= m <= 500

1 <= languages[i].length <= n

1 <= languages[i][j] <= n

1 <= u​​​​​​i < v​​​​​​i <= languages.length

1 <= friendships.length <= 500

All tuples (u​​​​​i, v​​​​​​i) are unique

languages[i] contains only unique values

```Java
class Solution {
    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        
    }
}
```


Approach: Greedy
Intuition
The task requires us to choose a language so that all friends can communicate with each other. Between any two friends, there are two possible situations:

If their sets of languages intersect, they can communicate with each other.
If their sets of languages do not intersect, they cannot communicate with each other.
In the first case, we do not need to do anything, since the friends can already communicate. In the second case, we need to choose a language that both friends can learn, which will allow them to communicate.

Our goal is to find the minimum number of people who need to be taught a language. To do this, we first identify all friends who cannot currently communicate with each other.

Next, we need to find a language that all of these friends could potentially learn. If they all share this language, then communication becomes possible.

How do we select such a language? We count how many of the non-communicating friends already know each language, and then greedily choose the language known by the largest number of them. This minimizes the number of additional people who need to learn it. It can be proven that choosing any other language would result in teaching at least as many, if not more, people. Therefore, this greedy strategy is correct.

For the implementation, we use a hash table mp to check whether each pair of friends can already communicate. We then use a set cncon to store all friends who cannot communicate. We also maintain an array cnt of length n to count how many of these friends know each language. Finally, we find the maximum value \textit{max_cnt} in this array. The minimum number of people to teach is then given by the size of the cncon set minus \textit{max_cnt}.

```Java
class Solution {

    public int minimumTeachings(int n, int[][] languages, int[][] friendships) {
        Set<Integer> cncon = new HashSet<>();
        for (int[] friendship : friendships) {
            Map<Integer, Integer> mp = new HashMap<>();
            boolean conm = false;
            for (int lan : languages[friendship[0] - 1]) {
                mp.put(lan, 1);
            }
            for (int lan : languages[friendship[1] - 1]) {
                if (mp.containsKey(lan)) {
                    conm = true;
                    break;
                }
            }
            if (!conm) {
                cncon.add(friendship[0] - 1);
                cncon.add(friendship[1] - 1);
            }
        }
        int max_cnt = 0;
        int[] cnt = new int[n + 1];
        for (int friendship : cncon) {
            for (int lan : languages[friendship]) {
                cnt[lan]++;
                max_cnt = Math.max(max_cnt, cnt[lan]);
            }
        }
        return cncon.size() - max_cnt;
    }
}
```
